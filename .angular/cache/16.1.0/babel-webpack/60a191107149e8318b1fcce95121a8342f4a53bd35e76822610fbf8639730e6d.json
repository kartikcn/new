{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @license\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://raw.githubusercontent.com/l-lin/angular-datatables/master/LICENSE\n */\nimport { Directive, ElementRef, Input, Renderer2, ViewContainerRef } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nvar DataTableDirective = /** @class */function () {\n  function DataTableDirective(el, vcr, renderer) {\n    this.el = el;\n    this.vcr = vcr;\n    this.renderer = renderer;\n    /**\n     * The DataTable option you pass to configure your table.\n     */\n    this.dtOptions = {};\n  }\n  DataTableDirective.prototype.ngOnInit = function () {\n    var _this = this;\n    if (this.dtTrigger) {\n      this.dtTrigger.subscribe(function (options) {\n        _this.displayTable(options);\n      });\n    } else {\n      this.displayTable(null);\n    }\n  };\n  DataTableDirective.prototype.ngOnDestroy = function () {\n    if (this.dtTrigger) {\n      this.dtTrigger.unsubscribe();\n    }\n    if (this.dt) {\n      this.dt.destroy(true);\n    }\n  };\n  DataTableDirective.prototype.displayTable = function (dtOptions) {\n    var _this = this;\n    // assign new options if provided\n    if (dtOptions) {\n      this.dtOptions = dtOptions;\n    }\n    this.dtInstance = new Promise(function (resolve, reject) {\n      Promise.resolve(_this.dtOptions).then(function (resolvedDTOptions) {\n        // validate object\n        var isTableEmpty = Object.keys(resolvedDTOptions).length === 0 && $('tbody tr', _this.el.nativeElement).length === 0;\n        if (isTableEmpty) {\n          reject('Both the table and dtOptions cannot be empty');\n          return;\n        }\n        // Using setTimeout as a \"hack\" to be \"part\" of NgZone\n        setTimeout(function () {\n          // Assign DT properties here\n          var options = {\n            rowCallback: function (row, data, index) {\n              if (resolvedDTOptions.columns) {\n                var columns = resolvedDTOptions.columns;\n                _this.applyNgPipeTransform(row, columns);\n                _this.applyNgRefTemplate(row, columns, data);\n              }\n              // run user specified row callback if provided.\n              if (resolvedDTOptions.rowCallback) {\n                resolvedDTOptions.rowCallback(row, data, index);\n              }\n            }\n          };\n          // merge user's config with ours\n          options = Object.assign({}, resolvedDTOptions, options);\n          _this.dt = $(_this.el.nativeElement).DataTable(options);\n          resolve(_this.dt);\n        });\n      });\n    });\n  };\n  DataTableDirective.prototype.applyNgPipeTransform = function (row, columns) {\n    // Filter columns with pipe declared\n    var colsWithPipe = columns.filter(function (x) {\n      return x.ngPipeInstance && !x.ngTemplateRef;\n    });\n    colsWithPipe.forEach(function (el) {\n      var pipe = el.ngPipeInstance;\n      var pipeArgs = el.ngPipeArgs || [];\n      // find index of column using `data` attr\n      var i = columns.filter(function (c) {\n        return c.visible !== false;\n      }).findIndex(function (e) {\n        return e.data === el.data;\n      });\n      // get <td> element which holds data using index\n      var rowFromCol = row.childNodes.item(i);\n      // Transform data with Pipe and PipeArgs\n      var rowVal = $(rowFromCol).text();\n      var rowValAfter = pipe.transform.apply(pipe, __spreadArray([rowVal], pipeArgs, false));\n      // Apply transformed string to <td>\n      $(rowFromCol).text(rowValAfter);\n    });\n  };\n  DataTableDirective.prototype.applyNgRefTemplate = function (row, columns, data) {\n    var _this = this;\n    // Filter columns using `ngTemplateRef`\n    var colsWithTemplate = columns.filter(function (x) {\n      return x.ngTemplateRef && !x.ngPipeInstance;\n    });\n    colsWithTemplate.forEach(function (el) {\n      var _a = el.ngTemplateRef,\n        ref = _a.ref,\n        context = _a.context;\n      // get <td> element which holds data using index\n      var i = columns.filter(function (c) {\n        return c.visible !== false;\n      }).findIndex(function (e) {\n        return e.data === el.data;\n      });\n      var cellFromIndex = row.childNodes.item(i);\n      // reset cell before applying transform\n      $(cellFromIndex).html('');\n      // render onto DOM\n      // finalize context to be sent to user\n      var _context = Object.assign({}, context, context === null || context === void 0 ? void 0 : context.userData, {\n        adtData: data\n      });\n      var instance = _this.vcr.createEmbeddedView(ref, _context);\n      _this.renderer.appendChild(cellFromIndex, instance.rootNodes[0]);\n    });\n  };\n  DataTableDirective.ɵfac = function DataTableDirective_Factory(t) {\n    return new (t || DataTableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  DataTableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DataTableDirective,\n    selectors: [[\"\", \"datatable\", \"\"]],\n    inputs: {\n      dtOptions: \"dtOptions\",\n      dtTrigger: \"dtTrigger\"\n    }\n  });\n  return DataTableDirective;\n}();\nexport { DataTableDirective };\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n//# sourceMappingURL=angular-datatables.directive.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}