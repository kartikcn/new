{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { Directive, Optional, Self, Input, Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChildren, isDevMode, ContentChild, NgModule } from '@angular/core';\nimport { Subject, merge, EMPTY } from 'rxjs';\nimport { distinctUntilChanged, takeUntil, filter, startWith, switchMap, mergeMap, map } from 'rxjs/operators';\nimport * as i3 from 'ng-zorro-antd/core/form';\nimport { NzFormItemFeedbackIconComponent, NzFormNoStatusService, NzFormPatchModule } from 'ng-zorro-antd/core/form';\nimport { getStatusClassNames, InputBoolean, isNotNil } from 'ng-zorro-antd/core/util';\nimport * as i1 from '@angular/forms';\nimport * as i2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i1$1 from '@angular/cdk/a11y';\nimport * as i4 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i2$1 from 'ng-zorro-antd/icon';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\nimport * as i3$1 from 'ng-zorro-antd/core/outlet';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nimport * as i1$2 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport * as i2$2 from 'ng-zorro-antd/core/services';\nconst _c0 = [\"nz-input-group-slot\", \"\"];\nfunction NzInputGroupSlotComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 2);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"nzType\", ctx_r0.icon);\n  }\n}\nfunction NzInputGroupSlotComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.template);\n  }\n}\nconst _c1 = [\"*\"];\nfunction NzInputGroupComponent_span_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"icon\", ctx_r7.nzAddOnBeforeIcon)(\"template\", ctx_r7.nzAddOnBefore);\n  }\n}\nfunction NzInputGroupComponent_span_0_span_2_ng_template_1_Template(rf, ctx) {}\nfunction NzInputGroupComponent_span_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8);\n    i0.ɵɵtemplate(1, NzInputGroupComponent_span_0_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    const _r3 = i0.ɵɵreference(4);\n    i0.ɵɵclassProp(\"ant-input-affix-wrapper-disabled\", ctx_r8.disabled)(\"ant-input-affix-wrapper-sm\", ctx_r8.isSmall)(\"ant-input-affix-wrapper-lg\", ctx_r8.isLarge)(\"ant-input-affix-wrapper-focused\", ctx_r8.focused);\n    i0.ɵɵproperty(\"ngClass\", ctx_r8.affixInGroupStatusCls);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\nfunction NzInputGroupComponent_span_0_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"icon\", ctx_r9.nzAddOnAfterIcon)(\"template\", ctx_r9.nzAddOnAfter);\n  }\n}\nfunction NzInputGroupComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtemplate(1, NzInputGroupComponent_span_0_span_1_Template, 1, 2, \"span\", 5);\n    i0.ɵɵtemplate(2, NzInputGroupComponent_span_0_span_2_Template, 2, 10, \"span\", 6);\n    i0.ɵɵtemplate(3, NzInputGroupComponent_span_0_span_3_Template, 1, 2, \"span\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.nzAddOnBefore || ctx_r0.nzAddOnBeforeIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isAffix || ctx_r0.hasFeedback)(\"ngIfElse\", _r5);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.nzAddOnAfter || ctx_r0.nzAddOnAfterIcon);\n  }\n}\nfunction NzInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template(rf, ctx) {}\nfunction NzInputGroupComponent_ng_template_1_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NzInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n    const _r3 = i0.ɵɵreference(4);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\nfunction NzInputGroupComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NzInputGroupComponent_ng_template_1_ng_template_0_Template, 1, 1, \"ng-template\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(6);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isAffix)(\"ngIfElse\", _r5);\n  }\n}\nfunction NzInputGroupComponent_ng_template_3_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"icon\", ctx_r13.nzPrefixIcon)(\"template\", ctx_r13.nzPrefix);\n  }\n}\nfunction NzInputGroupComponent_ng_template_3_ng_template_1_Template(rf, ctx) {}\nfunction NzInputGroupComponent_ng_template_3_span_2_nz_form_item_feedback_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"nz-form-item-feedback-icon\", 16);\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"status\", ctx_r16.status);\n  }\n}\nfunction NzInputGroupComponent_ng_template_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 14);\n    i0.ɵɵtemplate(1, NzInputGroupComponent_ng_template_3_span_2_nz_form_item_feedback_icon_1_Template, 1, 1, \"nz-form-item-feedback-icon\", 15);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"icon\", ctx_r15.nzSuffixIcon)(\"template\", ctx_r15.nzSuffix);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.isFeedback);\n  }\n}\nfunction NzInputGroupComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NzInputGroupComponent_ng_template_3_span_0_Template, 1, 2, \"span\", 11);\n    i0.ɵɵtemplate(1, NzInputGroupComponent_ng_template_3_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵtemplate(2, NzInputGroupComponent_ng_template_3_span_2_Template, 2, 3, \"span\", 12);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(6);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.nzPrefix || ctx_r4.nzPrefixIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.nzSuffix || ctx_r4.nzSuffixIcon || ctx_r4.isFeedback);\n  }\n}\nfunction NzInputGroupComponent_ng_template_5_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵelement(1, \"nz-form-item-feedback-icon\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"status\", ctx_r17.status);\n  }\n}\nfunction NzInputGroupComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n    i0.ɵɵtemplate(1, NzInputGroupComponent_ng_template_5_span_1_Template, 2, 1, \"span\", 17);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.isAddOn && !ctx_r6.isAffix && ctx_r6.isFeedback);\n  }\n}\nconst _c2 = [[[\"textarea\", \"nz-input\", \"\"]]];\nconst _c3 = [\"textarea[nz-input]\"];\nlet NzInputDirective = /*#__PURE__*/(() => {\n  class NzInputDirective {\n    get disabled() {\n      if (this.ngControl && this.ngControl.disabled !== null) {\n        return this.ngControl.disabled;\n      }\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = value != null && `${value}` !== 'false';\n    }\n    constructor(ngControl, renderer, elementRef, hostView, directionality, nzFormStatusService, nzFormNoStatusService) {\n      this.ngControl = ngControl;\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.hostView = hostView;\n      this.directionality = directionality;\n      this.nzFormStatusService = nzFormStatusService;\n      this.nzFormNoStatusService = nzFormNoStatusService;\n      this.nzBorderless = false;\n      this.nzSize = 'default';\n      this.nzStatus = '';\n      this._disabled = false;\n      this.disabled$ = new Subject();\n      this.dir = 'ltr';\n      // status\n      this.prefixCls = 'ant-input';\n      this.status = '';\n      this.statusCls = {};\n      this.hasFeedback = false;\n      this.feedbackRef = null;\n      this.components = [];\n      this.destroy$ = new Subject();\n    }\n    ngOnInit() {\n      this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {\n        return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;\n      }), takeUntil(this.destroy$)).subscribe(({\n        status,\n        hasFeedback\n      }) => {\n        this.setStatusStyles(status, hasFeedback);\n      });\n      if (this.ngControl) {\n        this.ngControl.statusChanges?.pipe(filter(() => this.ngControl.disabled !== null), takeUntil(this.destroy$)).subscribe(() => {\n          this.disabled$.next(this.ngControl.disabled);\n        });\n      }\n      this.dir = this.directionality.value;\n      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n    ngOnChanges(changes) {\n      const {\n        disabled,\n        nzStatus\n      } = changes;\n      if (disabled) {\n        this.disabled$.next(this.disabled);\n      }\n      if (nzStatus) {\n        this.setStatusStyles(this.nzStatus, this.hasFeedback);\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    setStatusStyles(status, hasFeedback) {\n      // set inner status\n      this.status = status;\n      this.hasFeedback = hasFeedback;\n      this.renderFeedbackIcon();\n      // render status if nzStatus is set\n      this.statusCls = getStatusClassNames(this.prefixCls, status, hasFeedback);\n      Object.keys(this.statusCls).forEach(status => {\n        if (this.statusCls[status]) {\n          this.renderer.addClass(this.elementRef.nativeElement, status);\n        } else {\n          this.renderer.removeClass(this.elementRef.nativeElement, status);\n        }\n      });\n    }\n    renderFeedbackIcon() {\n      if (!this.status || !this.hasFeedback || !!this.nzFormNoStatusService) {\n        // remove feedback\n        this.hostView.clear();\n        this.feedbackRef = null;\n        return;\n      }\n      this.feedbackRef = this.feedbackRef || this.hostView.createComponent(NzFormItemFeedbackIconComponent);\n      this.feedbackRef.location.nativeElement.classList.add('ant-input-suffix');\n      this.feedbackRef.instance.status = this.status;\n      this.feedbackRef.instance.updateIcon();\n    }\n    static #_ = this.ɵfac = function NzInputDirective_Factory(t) {\n      return new (t || NzInputDirective)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2.Directionality, 8), i0.ɵɵdirectiveInject(i3.NzFormStatusService, 8), i0.ɵɵdirectiveInject(i3.NzFormNoStatusService, 8));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NzInputDirective,\n      selectors: [[\"input\", \"nz-input\", \"\"], [\"textarea\", \"nz-input\", \"\"]],\n      hostAttrs: [1, \"ant-input\"],\n      hostVars: 11,\n      hostBindings: function NzInputDirective_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"disabled\", ctx.disabled || null);\n          i0.ɵɵclassProp(\"ant-input-disabled\", ctx.disabled)(\"ant-input-borderless\", ctx.nzBorderless)(\"ant-input-lg\", ctx.nzSize === \"large\")(\"ant-input-sm\", ctx.nzSize === \"small\")(\"ant-input-rtl\", ctx.dir === \"rtl\");\n        }\n      },\n      inputs: {\n        nzBorderless: \"nzBorderless\",\n        nzSize: \"nzSize\",\n        nzStatus: \"nzStatus\",\n        disabled: \"disabled\"\n      },\n      exportAs: [\"nzInput\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  __decorate([InputBoolean()], NzInputDirective.prototype, \"nzBorderless\", void 0);\n  return NzInputDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzInputGroupSlotComponent = /*#__PURE__*/(() => {\n  class NzInputGroupSlotComponent {\n    constructor() {\n      this.icon = null;\n      this.type = null;\n      this.template = null;\n    }\n    static #_ = this.ɵfac = function NzInputGroupSlotComponent_Factory(t) {\n      return new (t || NzInputGroupSlotComponent)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NzInputGroupSlotComponent,\n      selectors: [[\"\", \"nz-input-group-slot\", \"\"]],\n      hostVars: 6,\n      hostBindings: function NzInputGroupSlotComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"ant-input-group-addon\", ctx.type === \"addon\")(\"ant-input-prefix\", ctx.type === \"prefix\")(\"ant-input-suffix\", ctx.type === \"suffix\");\n        }\n      },\n      inputs: {\n        icon: \"icon\",\n        type: \"type\",\n        template: \"template\"\n      },\n      attrs: _c0,\n      ngContentSelectors: _c1,\n      decls: 3,\n      vars: 2,\n      consts: [[\"nz-icon\", \"\", 3, \"nzType\", 4, \"ngIf\"], [4, \"nzStringTemplateOutlet\"], [\"nz-icon\", \"\", 3, \"nzType\"]],\n      template: function NzInputGroupSlotComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵtemplate(0, NzInputGroupSlotComponent_span_0_Template, 1, 1, \"span\", 0);\n          i0.ɵɵtemplate(1, NzInputGroupSlotComponent_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n          i0.ɵɵprojection(2);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngIf\", ctx.icon);\n          i0.ɵɵadvance(1);\n          i0.ɵɵproperty(\"nzStringTemplateOutlet\", ctx.template);\n        }\n      },\n      dependencies: [i4.NgIf, i2$1.NzIconDirective, i3$1.NzStringTemplateOutletDirective],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NzInputGroupSlotComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NzInputGroupWhitSuffixOrPrefixDirective = /*#__PURE__*/(() => {\n  class NzInputGroupWhitSuffixOrPrefixDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n    static #_ = this.ɵfac = function NzInputGroupWhitSuffixOrPrefixDirective_Factory(t) {\n      return new (t || NzInputGroupWhitSuffixOrPrefixDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NzInputGroupWhitSuffixOrPrefixDirective,\n      selectors: [[\"nz-input-group\", \"nzSuffix\", \"\"], [\"nz-input-group\", \"nzPrefix\", \"\"]]\n    });\n  }\n  return NzInputGroupWhitSuffixOrPrefixDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NzInputGroupComponent = /*#__PURE__*/(() => {\n  class NzInputGroupComponent {\n    constructor(focusMonitor, elementRef, renderer, cdr, directionality, nzFormStatusService, nzFormNoStatusService) {\n      this.focusMonitor = focusMonitor;\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.directionality = directionality;\n      this.nzFormStatusService = nzFormStatusService;\n      this.nzFormNoStatusService = nzFormNoStatusService;\n      this.nzAddOnBeforeIcon = null;\n      this.nzAddOnAfterIcon = null;\n      this.nzPrefixIcon = null;\n      this.nzSuffixIcon = null;\n      this.nzStatus = '';\n      this.nzSize = 'default';\n      this.nzSearch = false;\n      this.nzCompact = false;\n      this.isLarge = false;\n      this.isSmall = false;\n      this.isAffix = false;\n      this.isAddOn = false;\n      this.isFeedback = false;\n      this.focused = false;\n      this.disabled = false;\n      this.dir = 'ltr';\n      // status\n      this.prefixCls = 'ant-input';\n      this.affixStatusCls = {};\n      this.groupStatusCls = {};\n      this.affixInGroupStatusCls = {};\n      this.status = '';\n      this.hasFeedback = false;\n      this.destroy$ = new Subject();\n    }\n    updateChildrenInputSize() {\n      if (this.listOfNzInputDirective) {\n        this.listOfNzInputDirective.forEach(item => item.nzSize = this.nzSize);\n      }\n    }\n    ngOnInit() {\n      this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {\n        return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;\n      }), takeUntil(this.destroy$)).subscribe(({\n        status,\n        hasFeedback\n      }) => {\n        this.setStatusStyles(status, hasFeedback);\n      });\n      this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe(focusOrigin => {\n        this.focused = !!focusOrigin;\n        this.cdr.markForCheck();\n      });\n      this.dir = this.directionality.value;\n      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n    ngAfterContentInit() {\n      this.updateChildrenInputSize();\n      const listOfInputChange$ = this.listOfNzInputDirective.changes.pipe(startWith(this.listOfNzInputDirective));\n      listOfInputChange$.pipe(switchMap(list => merge(...[listOfInputChange$, ...list.map(input => input.disabled$)])), mergeMap(() => listOfInputChange$), map(list => list.some(input => input.disabled)), takeUntil(this.destroy$)).subscribe(disabled => {\n        this.disabled = disabled;\n        this.cdr.markForCheck();\n      });\n    }\n    ngOnChanges(changes) {\n      const {\n        nzSize,\n        nzSuffix,\n        nzPrefix,\n        nzPrefixIcon,\n        nzSuffixIcon,\n        nzAddOnAfter,\n        nzAddOnBefore,\n        nzAddOnAfterIcon,\n        nzAddOnBeforeIcon,\n        nzStatus\n      } = changes;\n      if (nzSize) {\n        this.updateChildrenInputSize();\n        this.isLarge = this.nzSize === 'large';\n        this.isSmall = this.nzSize === 'small';\n      }\n      if (nzSuffix || nzPrefix || nzPrefixIcon || nzSuffixIcon) {\n        this.isAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);\n      }\n      if (nzAddOnAfter || nzAddOnBefore || nzAddOnAfterIcon || nzAddOnBeforeIcon) {\n        this.isAddOn = !!(this.nzAddOnAfter || this.nzAddOnBefore || this.nzAddOnAfterIcon || this.nzAddOnBeforeIcon);\n        this.nzFormNoStatusService?.noFormStatus?.next(this.isAddOn);\n      }\n      if (nzStatus) {\n        this.setStatusStyles(this.nzStatus, this.hasFeedback);\n      }\n    }\n    ngOnDestroy() {\n      this.focusMonitor.stopMonitoring(this.elementRef);\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    setStatusStyles(status, hasFeedback) {\n      // set inner status\n      this.status = status;\n      this.hasFeedback = hasFeedback;\n      this.isFeedback = !!status && hasFeedback;\n      const baseAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);\n      this.isAffix = baseAffix || !this.isAddOn && hasFeedback;\n      this.affixInGroupStatusCls = this.isAffix || this.isFeedback ? this.affixStatusCls = getStatusClassNames(`${this.prefixCls}-affix-wrapper`, status, hasFeedback) : {};\n      this.cdr.markForCheck();\n      // render status if nzStatus is set\n      this.affixStatusCls = getStatusClassNames(`${this.prefixCls}-affix-wrapper`, this.isAddOn ? '' : status, this.isAddOn ? false : hasFeedback);\n      this.groupStatusCls = getStatusClassNames(`${this.prefixCls}-group-wrapper`, this.isAddOn ? status : '', this.isAddOn ? hasFeedback : false);\n      const statusCls = {\n        ...this.affixStatusCls,\n        ...this.groupStatusCls\n      };\n      Object.keys(statusCls).forEach(status => {\n        if (statusCls[status]) {\n          this.renderer.addClass(this.elementRef.nativeElement, status);\n        } else {\n          this.renderer.removeClass(this.elementRef.nativeElement, status);\n        }\n      });\n    }\n    static #_ = this.ɵfac = function NzInputGroupComponent_Factory(t) {\n      return new (t || NzInputGroupComponent)(i0.ɵɵdirectiveInject(i1$1.FocusMonitor), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.Directionality, 8), i0.ɵɵdirectiveInject(i3.NzFormStatusService, 8), i0.ɵɵdirectiveInject(i3.NzFormNoStatusService, 8));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NzInputGroupComponent,\n      selectors: [[\"nz-input-group\"]],\n      contentQueries: function NzInputGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NzInputDirective, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.listOfNzInputDirective = _t);\n        }\n      },\n      hostVars: 40,\n      hostBindings: function NzInputGroupComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"ant-input-group-compact\", ctx.nzCompact)(\"ant-input-search-enter-button\", ctx.nzSearch)(\"ant-input-search\", ctx.nzSearch)(\"ant-input-search-rtl\", ctx.dir === \"rtl\")(\"ant-input-search-sm\", ctx.nzSearch && ctx.isSmall)(\"ant-input-search-large\", ctx.nzSearch && ctx.isLarge)(\"ant-input-group-wrapper\", ctx.isAddOn)(\"ant-input-group-wrapper-rtl\", ctx.dir === \"rtl\")(\"ant-input-group-wrapper-lg\", ctx.isAddOn && ctx.isLarge)(\"ant-input-group-wrapper-sm\", ctx.isAddOn && ctx.isSmall)(\"ant-input-affix-wrapper\", ctx.isAffix && !ctx.isAddOn)(\"ant-input-affix-wrapper-rtl\", ctx.dir === \"rtl\")(\"ant-input-affix-wrapper-focused\", ctx.isAffix && ctx.focused)(\"ant-input-affix-wrapper-disabled\", ctx.isAffix && ctx.disabled)(\"ant-input-affix-wrapper-lg\", ctx.isAffix && !ctx.isAddOn && ctx.isLarge)(\"ant-input-affix-wrapper-sm\", ctx.isAffix && !ctx.isAddOn && ctx.isSmall)(\"ant-input-group\", !ctx.isAffix && !ctx.isAddOn)(\"ant-input-group-rtl\", ctx.dir === \"rtl\")(\"ant-input-group-lg\", !ctx.isAffix && !ctx.isAddOn && ctx.isLarge)(\"ant-input-group-sm\", !ctx.isAffix && !ctx.isAddOn && ctx.isSmall);\n        }\n      },\n      inputs: {\n        nzAddOnBeforeIcon: \"nzAddOnBeforeIcon\",\n        nzAddOnAfterIcon: \"nzAddOnAfterIcon\",\n        nzPrefixIcon: \"nzPrefixIcon\",\n        nzSuffixIcon: \"nzSuffixIcon\",\n        nzAddOnBefore: \"nzAddOnBefore\",\n        nzAddOnAfter: \"nzAddOnAfter\",\n        nzPrefix: \"nzPrefix\",\n        nzStatus: \"nzStatus\",\n        nzSuffix: \"nzSuffix\",\n        nzSize: \"nzSize\",\n        nzSearch: \"nzSearch\",\n        nzCompact: \"nzCompact\"\n      },\n      exportAs: [\"nzInputGroup\"],\n      features: [i0.ɵɵProvidersFeature([NzFormNoStatusService]), i0.ɵɵNgOnChangesFeature],\n      ngContentSelectors: _c1,\n      decls: 7,\n      vars: 2,\n      consts: [[\"class\", \"ant-input-wrapper ant-input-group\", 4, \"ngIf\", \"ngIfElse\"], [\"noAddOnTemplate\", \"\"], [\"affixTemplate\", \"\"], [\"contentTemplate\", \"\"], [1, \"ant-input-wrapper\", \"ant-input-group\"], [\"nz-input-group-slot\", \"\", \"type\", \"addon\", 3, \"icon\", \"template\", 4, \"ngIf\"], [\"class\", \"ant-input-affix-wrapper\", 3, \"ant-input-affix-wrapper-disabled\", \"ant-input-affix-wrapper-sm\", \"ant-input-affix-wrapper-lg\", \"ant-input-affix-wrapper-focused\", \"ngClass\", 4, \"ngIf\", \"ngIfElse\"], [\"nz-input-group-slot\", \"\", \"type\", \"addon\", 3, \"icon\", \"template\"], [1, \"ant-input-affix-wrapper\", 3, \"ngClass\"], [3, \"ngTemplateOutlet\"], [3, \"ngIf\", \"ngIfElse\"], [\"nz-input-group-slot\", \"\", \"type\", \"prefix\", 3, \"icon\", \"template\", 4, \"ngIf\"], [\"nz-input-group-slot\", \"\", \"type\", \"suffix\", 3, \"icon\", \"template\", 4, \"ngIf\"], [\"nz-input-group-slot\", \"\", \"type\", \"prefix\", 3, \"icon\", \"template\"], [\"nz-input-group-slot\", \"\", \"type\", \"suffix\", 3, \"icon\", \"template\"], [3, \"status\", 4, \"ngIf\"], [3, \"status\"], [\"nz-input-group-slot\", \"\", \"type\", \"suffix\", 4, \"ngIf\"], [\"nz-input-group-slot\", \"\", \"type\", \"suffix\"]],\n      template: function NzInputGroupComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵtemplate(0, NzInputGroupComponent_span_0_Template, 4, 4, \"span\", 0);\n          i0.ɵɵtemplate(1, NzInputGroupComponent_ng_template_1_Template, 1, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n          i0.ɵɵtemplate(3, NzInputGroupComponent_ng_template_3_Template, 3, 3, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n          i0.ɵɵtemplate(5, NzInputGroupComponent_ng_template_5_Template, 2, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        }\n        if (rf & 2) {\n          const _r1 = i0.ɵɵreference(2);\n          i0.ɵɵproperty(\"ngIf\", ctx.isAddOn)(\"ngIfElse\", _r1);\n        }\n      },\n      dependencies: [i4.NgClass, i4.NgIf, i4.NgTemplateOutlet, i3.NzFormItemFeedbackIconComponent, NzInputGroupSlotComponent],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  __decorate([InputBoolean()], NzInputGroupComponent.prototype, \"nzSearch\", void 0);\n  __decorate([InputBoolean()], NzInputGroupComponent.prototype, \"nzCompact\", void 0);\n  return NzInputGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NzAutosizeDirective = /*#__PURE__*/(() => {\n  class NzAutosizeDirective {\n    set nzAutosize(value) {\n      const isAutoSizeType = data => typeof data !== 'string' && typeof data !== 'boolean' && (!!data.maxRows || !!data.minRows);\n      if (typeof value === 'string' || value === true) {\n        this.autosize = true;\n      } else if (isAutoSizeType(value)) {\n        this.autosize = true;\n        this.minRows = value.minRows;\n        this.maxRows = value.maxRows;\n        this.maxHeight = this.setMaxHeight();\n        this.minHeight = this.setMinHeight();\n      }\n    }\n    resizeToFitContent(force = false) {\n      this.cacheTextareaLineHeight();\n      // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n      // in checking the height of the textarea.\n      if (!this.cachedLineHeight) {\n        return;\n      }\n      const textarea = this.el;\n      const value = textarea.value;\n      // Only resize if the value or minRows have changed since these calculations can be expensive.\n      if (!force && this.minRows === this.previousMinRows && value === this.previousValue) {\n        return;\n      }\n      const placeholderText = textarea.placeholder;\n      // Reset the textarea height to auto in order to shrink back to its default size.\n      // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n      // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n      // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n      // need to be removed temporarily.\n      textarea.classList.add('nz-textarea-autosize-measuring');\n      textarea.placeholder = '';\n      let height = Math.round((textarea.scrollHeight - this.inputGap) / this.cachedLineHeight) * this.cachedLineHeight + this.inputGap;\n      if (this.maxHeight !== null && height > this.maxHeight) {\n        height = this.maxHeight;\n      }\n      if (this.minHeight !== null && height < this.minHeight) {\n        height = this.minHeight;\n      }\n      // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n      textarea.style.height = `${height}px`;\n      textarea.classList.remove('nz-textarea-autosize-measuring');\n      textarea.placeholder = placeholderText;\n      // On Firefox resizing the textarea will prevent it from scrolling to the caret position.\n      // We need to re-set the selection in order for it to scroll to the proper position.\n      if (typeof requestAnimationFrame !== 'undefined') {\n        this.ngZone.runOutsideAngular(() => requestAnimationFrame(() => {\n          const {\n            selectionStart,\n            selectionEnd\n          } = textarea;\n          // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n          // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n          // between the time we requested the animation frame and when it was executed.\n          // Also note that we have to assert that the textarea is focused before we set the\n          // selection range. Setting the selection range on a non-focused textarea will cause\n          // it to receive focus on IE and Edge.\n          if (!this.destroy$.isStopped && document.activeElement === textarea) {\n            textarea.setSelectionRange(selectionStart, selectionEnd);\n          }\n        }));\n      }\n      this.previousValue = value;\n      this.previousMinRows = this.minRows;\n    }\n    cacheTextareaLineHeight() {\n      if (this.cachedLineHeight >= 0 || !this.el.parentNode) {\n        return;\n      }\n      // Use a clone element because we have to override some styles.\n      const textareaClone = this.el.cloneNode(false);\n      textareaClone.rows = 1;\n      // Use `position: absolute` so that this doesn't cause a browser layout and use\n      // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n      // would affect the height.\n      textareaClone.style.position = 'absolute';\n      textareaClone.style.visibility = 'hidden';\n      textareaClone.style.border = 'none';\n      textareaClone.style.padding = '0';\n      textareaClone.style.height = '';\n      textareaClone.style.minHeight = '';\n      textareaClone.style.maxHeight = '';\n      // In Firefox it happens that textarea elements are always bigger than the specified amount\n      // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n      // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n      // to hidden. This ensures that there is no invalid calculation of the line height.\n      // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n      textareaClone.style.overflow = 'hidden';\n      this.el.parentNode.appendChild(textareaClone);\n      this.cachedLineHeight = textareaClone.clientHeight - this.inputGap;\n      this.el.parentNode.removeChild(textareaClone);\n      // Min and max heights have to be re-calculated if the cached line height changes\n      this.maxHeight = this.setMaxHeight();\n      this.minHeight = this.setMinHeight();\n    }\n    setMinHeight() {\n      const minHeight = this.minRows && this.cachedLineHeight ? this.minRows * this.cachedLineHeight + this.inputGap : null;\n      if (minHeight !== null) {\n        this.el.style.minHeight = `${minHeight}px`;\n      }\n      return minHeight;\n    }\n    setMaxHeight() {\n      const maxHeight = this.maxRows && this.cachedLineHeight ? this.maxRows * this.cachedLineHeight + this.inputGap : null;\n      if (maxHeight !== null) {\n        this.el.style.maxHeight = `${maxHeight}px`;\n      }\n      return maxHeight;\n    }\n    noopInputHandler() {\n      // no-op handler that ensures we're running change detection on input events.\n    }\n    constructor(elementRef, ngZone, platform, resizeService) {\n      this.elementRef = elementRef;\n      this.ngZone = ngZone;\n      this.platform = platform;\n      this.resizeService = resizeService;\n      this.autosize = false;\n      this.el = this.elementRef.nativeElement;\n      this.maxHeight = null;\n      this.minHeight = null;\n      this.destroy$ = new Subject();\n      this.inputGap = 10;\n    }\n    ngAfterViewInit() {\n      if (this.autosize && this.platform.isBrowser) {\n        this.resizeToFitContent();\n        this.resizeService.subscribe().pipe(takeUntil(this.destroy$)).subscribe(() => this.resizeToFitContent(true));\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    ngDoCheck() {\n      if (this.autosize && this.platform.isBrowser) {\n        this.resizeToFitContent();\n      }\n    }\n    static #_ = this.ɵfac = function NzAutosizeDirective_Factory(t) {\n      return new (t || NzAutosizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$2.Platform), i0.ɵɵdirectiveInject(i2$2.NzResizeService));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NzAutosizeDirective,\n      selectors: [[\"textarea\", \"nzAutosize\", \"\"]],\n      hostAttrs: [\"rows\", \"1\"],\n      hostBindings: function NzAutosizeDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function NzAutosizeDirective_input_HostBindingHandler() {\n            return ctx.noopInputHandler();\n          });\n        }\n      },\n      inputs: {\n        nzAutosize: \"nzAutosize\"\n      },\n      exportAs: [\"nzAutosize\"]\n    });\n  }\n  return NzAutosizeDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzTextareaCountComponent = /*#__PURE__*/(() => {\n  class NzTextareaCountComponent {\n    constructor(renderer, elementRef) {\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.nzMaxCharacterCount = 0;\n      this.nzComputeCharacterCount = v => v.length;\n      this.nzFormatter = (c, m) => `${c}${m > 0 ? `/${m}` : ``}`;\n      this.configChange$ = new Subject();\n      this.destroy$ = new Subject();\n    }\n    ngAfterContentInit() {\n      if (!this.nzInputDirective && isDevMode()) {\n        throw new Error('[nz-textarea-count]: Could not find matching textarea[nz-input] child.');\n      }\n      if (this.nzInputDirective.ngControl) {\n        const valueChanges = this.nzInputDirective.ngControl.valueChanges || EMPTY;\n        merge(valueChanges, this.configChange$).pipe(takeUntil(this.destroy$), map(() => this.nzInputDirective.ngControl.value), startWith(this.nzInputDirective.ngControl.value)).subscribe(value => {\n          this.setDataCount(value);\n        });\n      }\n    }\n    setDataCount(value) {\n      const inputValue = isNotNil(value) ? String(value) : '';\n      const currentCount = this.nzComputeCharacterCount(inputValue);\n      const dataCount = this.nzFormatter(currentCount, this.nzMaxCharacterCount);\n      this.renderer.setAttribute(this.elementRef.nativeElement, 'data-count', dataCount);\n    }\n    ngOnDestroy() {\n      this.configChange$.complete();\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    static #_ = this.ɵfac = function NzTextareaCountComponent_Factory(t) {\n      return new (t || NzTextareaCountComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NzTextareaCountComponent,\n      selectors: [[\"nz-textarea-count\"]],\n      contentQueries: function NzTextareaCountComponent_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NzInputDirective, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nzInputDirective = _t.first);\n        }\n      },\n      hostAttrs: [1, \"ant-input-textarea-show-count\"],\n      inputs: {\n        nzMaxCharacterCount: \"nzMaxCharacterCount\",\n        nzComputeCharacterCount: \"nzComputeCharacterCount\",\n        nzFormatter: \"nzFormatter\"\n      },\n      ngContentSelectors: _c3,\n      decls: 1,\n      vars: 0,\n      template: function NzTextareaCountComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c2);\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NzTextareaCountComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzInputModule = /*#__PURE__*/(() => {\n  class NzInputModule {\n    static #_ = this.ɵfac = function NzInputModule_Factory(t) {\n      return new (t || NzInputModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NzInputModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [BidiModule, CommonModule, NzIconModule, PlatformModule, NzOutletModule, NzFormPatchModule]\n    });\n  }\n  return NzInputModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzAutosizeDirective, NzInputDirective, NzInputGroupComponent, NzInputGroupSlotComponent, NzInputGroupWhitSuffixOrPrefixDirective, NzInputModule, NzTextareaCountComponent };\n//# sourceMappingURL=ng-zorro-antd-input.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}