{"ast":null,"code":"import * as d3 from 'd3';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"primeng/api\";\nimport * as i2 from \"primeng/dialog\";\nimport * as i3 from \"@angular/forms\";\nimport * as i4 from \"../../../../Helpdesk/requests-by-asset-reports/widgets/add-table/add-table.component\";\nfunction EscalationAlertsGridComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"h2\", 5);\n    i0.ɵɵtext(1, \"Request List\");\n    i0.ɵɵelementEnd();\n  }\n}\nfunction EscalationAlertsGridComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"app-add-table\", 6);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"data\", ctx_r1.detailsPopUpData)(\"isEscalatedData\", ctx_r1.viewForEscalation);\n  }\n}\nconst _c0 = function () {\n  return {\n    width: \"66vw\"\n  };\n};\nexport let EscalationAlertsGridComponent = /*#__PURE__*/(() => {\n  class EscalationAlertsGridComponent {\n    constructor() {\n      this.showPopupFlag = false;\n      this.viewForEscalation = true;\n      this.detailsPopUpData = [];\n      this.canvasWidth = 300;\n      this.needleValue = 0;\n      this.bottomLabel = this.needleValue + '%';\n      // guageOptions: any = {\n      //   hasNeedle: true,\n      //   needleColor: 'blue',\n      //   needleUpdateSpeed: 1000,\n      //   arcColors: ['red','green'],\n      //   arcDelimiters: [75],\n      //   rangeLabel: ['0','100'],\n      //   needleStartValue: 0,\n      // }\n      this.gaugemap = {};\n    }\n    ngOnInit() {\n      // this.draw();\n    }\n    setEscalatedPercantage(noEscalatedPercent) {\n      this.canvasWidth = 300;\n      this.needleValue = 0;\n      this.bottomLabel = this.needleValue + '%';\n      // this.guageOptions = {\n      //   hasNeedle: true,\n      //   needleColor: 'blue',\n      //   needleUpdateSpeed: 1000,\n      //   arcColors: ['red','green'],\n      //   arcOverEffect: false,\n      //   arcPadding : '10px',\n      //   arcDelimiters: [75],\n      //   rangeLabel: ['0', '100'],\n      //   needleStartValue: 0,\n      // }\n      const floatValue = parseFloat(noEscalatedPercent);\n      if (typeof floatValue === 'number' && !isNaN(floatValue)) {\n        this.needleValue = floatValue;\n        this.bottomLabel = this.needleValue + '%';\n        // this.guageOptions.needleStartValue = 0;\n      } else {\n        this.needleValue = 0;\n        this.bottomLabel = this.needleValue + '%';\n      }\n      this.draw();\n    }\n    onClickKnob() {\n      this.showPopupFlag = true;\n      this.detailsPopUpData = [];\n      this.detailsPopUpData.push(...this.noEsctdData);\n    }\n    draw() {\n      const self = this;\n      const gauge = function (container, configuration) {\n        const config = {\n          size: 300,\n          clipWidth: 300,\n          clipHeight: 300,\n          ringInset: 20,\n          ringWidth: 30,\n          pointerWidth: 10,\n          pointerTailLength: 5,\n          pointerHeadLengthPercent: 0.65,\n          minValue: 0,\n          maxValue: 100,\n          minAngle: -90,\n          maxAngle: 90,\n          transitionMs: 2000,\n          majorTicks: 5,\n          labelFormat: d3.format('d'),\n          labelInset: 10,\n          // arcColorFn: d3.interpolateHsl(d3.rgb('#e8e2ca'), d3.rgb('#3e6c0a'))\n          limitingValue: 0.75,\n          arcColorFn: [\"#ff0000\", \"#00ff00\"]\n        };\n        let range;\n        let r;\n        let pointerHeadLength;\n        let value = 0;\n        let svg;\n        let arc;\n        let scale;\n        let ticks;\n        let tickData;\n        let pointer;\n        const donut = d3.pie();\n        function deg2rad(deg) {\n          return deg * Math.PI / 180;\n        }\n        function newAngle(d) {\n          const ratio = scale(d);\n          const newAngle = config.minAngle + ratio * range;\n          return newAngle;\n        }\n        function configure(configuration) {\n          // for (const prop in configuration) {\n          //   if (configuration.hasOwnProperty(prop)) {\n          //     (config as any)[prop] = configuration[prop];\n          //   }\n          // }\n          range = config.maxAngle - config.minAngle;\n          r = config.size / 2;\n          pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);\n          scale = d3.scaleLinear().range([0, 1]).domain([config.minValue, config.maxValue]);\n          ticks = scale.ticks(config.majorTicks);\n          tickData = d3.range(config.majorTicks).map(() => 1 / config.majorTicks);\n          arc = d3.arc().innerRadius(r - config.ringWidth - config.ringInset).outerRadius(r - config.ringInset).startAngle((d, i) => {\n            // const ratio = d * i;\n            const ratio = i * config.limitingValue;\n            return deg2rad(config.minAngle + ratio * range);\n          }).endAngle((d, i) => {\n            // const ratio = d * (i + 1);\n            let ratio = (i + 1) * config.limitingValue;\n            if (ratio > 1) {\n              ratio = 1;\n            }\n            return deg2rad(config.minAngle + ratio * range);\n          });\n        }\n        self.gaugemap.configure = configure;\n        function centerTranslation() {\n          return `translate(${r},${r})`;\n        }\n        function isRendered() {\n          return svg !== undefined;\n        }\n        self.gaugemap.isRendered = isRendered;\n        function render(newValue) {\n          d3.select(container).selectAll(\"*\").remove();\n          svg = d3.select(container).append('svg:svg').attr('class', 'gauge').attr('width', config.clipWidth).attr('height', config.clipHeight);\n          const centerTx = centerTranslation();\n          const arcs = svg.append('g').attr('class', 'arc').attr('transform', centerTx);\n          arcs.selectAll('path')\n          // .data(tickData)\n          .data([0.5, 0.5]).enter().append('path').attr('fill', (d, i) => {\n            // return config.arcColorFn(d * i);\n            return config.arcColorFn[i];\n          }).attr('d', arc);\n          const lg = svg.append('g').attr('class', 'label').attr('transform', centerTx);\n          lg.selectAll('text').data(ticks).enter().append('text').attr('transform', d => {\n            const ratio = scale(d);\n            const newAngle = config.minAngle + ratio * range;\n            return `rotate(${newAngle}) translate(0,${config.labelInset - (r ?? 0)})`;\n          }).text(config.labelFormat);\n          const lineData = [[config.pointerWidth / 2, 0], [0, -pointerHeadLength], [-(config.pointerWidth / 2), 0], [0, config.pointerTailLength], [config.pointerWidth / 2, 0]];\n          const pointerLine = d3.line().curve(d3.curveLinear);\n          const pg = svg.append('g').data([lineData]).attr('class', 'pointer').attr('transform', centerTx);\n          pointer = pg.append('path').attr('d', pointerLine).attr('transform', `rotate(${config.minAngle})`);\n          update(newValue === undefined ? 0 : newValue);\n          const rv = svg.append('g').attr('class', 'pointerval').attr('transform', centerTx);\n          rv.append('text').attr('transform', 'rotate(0) translate(-30,70) scale(3)').text(newValue + '%');\n        }\n        self.gaugemap.render = render;\n        function update(newValue, newConfiguration) {\n          if (newConfiguration !== undefined) {\n            configure(newConfiguration);\n          }\n          const ratio = scale(newValue);\n          const newAngle = config.minAngle + ratio * range;\n          pointer.transition().duration(config.transitionMs).ease(d3.easeElastic).attr('transform', `rotate(${newAngle})`);\n        }\n        self.gaugemap.update = update;\n        configure(configuration);\n        return self.gaugemap;\n      };\n      const powerGauge = gauge('#power-gauge', {});\n      powerGauge.render(this.needleValue);\n    }\n    static #_ = this.ɵfac = function EscalationAlertsGridComponent_Factory(t) {\n      return new (t || EscalationAlertsGridComponent)();\n    };\n    static #_2 = this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: EscalationAlertsGridComponent,\n      selectors: [[\"app-escalation-alerts-grid\"]],\n      inputs: {\n        noEsctdData: \"noEsctdData\",\n        escalatedData: \"escalatedData\",\n        allEscalatedData: \"allEscalatedData\"\n      },\n      decls: 5,\n      vars: 8,\n      consts: [[2, \"display\", \"flex\", \"align-items\", \"center\", \"justify-content\", \"space-around\"], [\"id\", \"power-gauge\", 3, \"click\"], [\"styleClass\", \"dark-panel\", 3, \"visible\", \"modal\", \"maximizable\", \"draggable\", \"resizable\", \"visibleChange\"], [\"pTemplate\", \"header\"], [\"pTemplate\", \"body\"], [2, \"margin\", \"0px\"], [3, \"data\", \"isEscalatedData\"]],\n      template: function EscalationAlertsGridComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"form\", 0)(1, \"div\", 1);\n          i0.ɵɵlistener(\"click\", function EscalationAlertsGridComponent_Template_div_click_1_listener() {\n            return ctx.onClickKnob();\n          });\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(2, \"p-dialog\", 2);\n          i0.ɵɵlistener(\"visibleChange\", function EscalationAlertsGridComponent_Template_p_dialog_visibleChange_2_listener($event) {\n            return ctx.showPopupFlag = $event;\n          });\n          i0.ɵɵtemplate(3, EscalationAlertsGridComponent_ng_template_3_Template, 2, 0, \"ng-template\", 3);\n          i0.ɵɵtemplate(4, EscalationAlertsGridComponent_ng_template_4_Template, 1, 2, \"ng-template\", 4);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(2);\n          i0.ɵɵstyleMap(i0.ɵɵpureFunction0(7, _c0));\n          i0.ɵɵproperty(\"visible\", ctx.showPopupFlag)(\"modal\", true)(\"maximizable\", true)(\"draggable\", false)(\"resizable\", false);\n        }\n      },\n      dependencies: [i1.PrimeTemplate, i2.Dialog, i3.ɵNgNoValidate, i3.NgControlStatusGroup, i4.AddTableComponent],\n      styles: [\".p-knob-value{cursor:pointer}  .p-disabled, .p-disabled[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]{opacity:1}\"]\n    });\n  }\n  return EscalationAlertsGridComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}