{"ast":null,"code":"import * as i2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, Input, NgModule } from '@angular/core';\nimport * as i5 from 'ng-zorro-antd/core/outlet';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nimport * as i4 from 'ng-zorro-antd/icon';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\nimport { __decorate } from 'tslib';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i1 from 'ng-zorro-antd/core/config';\nimport { WithConfig } from 'ng-zorro-antd/core/config';\nimport { isNotNil, InputNumber } from 'ng-zorro-antd/core/util';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nfunction NzProgressComponent_ng_template_0_span_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"nzType\", ctx_r5.icon);\n  }\n}\nfunction NzProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const formatter_r9 = ctx.$implicit;\n    const ctx_r8 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", formatter_r9(ctx_r8.nzPercent), \" \");\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\nfunction NzProgressComponent_ng_template_0_span_0_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NzProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template, 2, 1, \"ng-container\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"nzStringTemplateOutlet\", ctx_r7.formatter)(\"nzStringTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c0, ctx_r7.nzPercent));\n  }\n}\nfunction NzProgressComponent_ng_template_0_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵtemplate(1, NzProgressComponent_ng_template_0_span_0_ng_container_1_Template, 2, 1, \"ng-container\", 6);\n    i0.ɵɵtemplate(2, NzProgressComponent_ng_template_0_span_0_ng_template_2_Template, 1, 4, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const _r6 = i0.ɵɵreference(3);\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", (ctx_r4.status === \"exception\" || ctx_r4.status === \"success\") && !ctx_r4.nzFormat)(\"ngIfElse\", _r6);\n  }\n}\nfunction NzProgressComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NzProgressComponent_ng_template_0_span_0_Template, 4, 2, \"span\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.nzShowInfo);\n  }\n}\nfunction NzProgressComponent_div_3_ng_container_1_div_1_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 17);\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(4);\n    i0.ɵɵstyleProp(\"width\", ctx_r14.nzSuccessPercent, \"%\")(\"border-radius\", ctx_r14.nzStrokeLinecap === \"round\" ? \"100px\" : \"0\")(\"height\", ctx_r14.strokeWidth, \"px\");\n  }\n}\nfunction NzProgressComponent_div_3_ng_container_1_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 13)(1, \"div\", 14);\n    i0.ɵɵelement(2, \"div\", 15);\n    i0.ɵɵtemplate(3, NzProgressComponent_div_3_ng_container_1_div_1_div_3_Template, 1, 6, \"div\", 16);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r12.nzPercent, \"%\")(\"border-radius\", ctx_r12.nzStrokeLinecap === \"round\" ? \"100px\" : \"0\")(\"background\", !ctx_r12.isGradient ? ctx_r12.nzStrokeColor : null)(\"background-image\", ctx_r12.isGradient ? ctx_r12.lineGradient : null)(\"height\", ctx_r12.strokeWidth, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.nzSuccessPercent || ctx_r12.nzSuccessPercent === 0);\n  }\n}\nfunction NzProgressComponent_div_3_ng_container_1_ng_template_2_Template(rf, ctx) {}\nfunction NzProgressComponent_div_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, NzProgressComponent_div_3_ng_container_1_div_1_Template, 4, 11, \"div\", 11);\n    i0.ɵɵtemplate(2, NzProgressComponent_div_3_ng_container_1_ng_template_2_Template, 0, 0, \"ng-template\", 12);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    const _r0 = i0.ɵɵreference(1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r10.isSteps);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r0);\n  }\n}\nfunction NzProgressComponent_div_3_div_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 20);\n  }\n  if (rf & 2) {\n    const step_r17 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngStyle\", step_r17);\n  }\n}\nfunction NzProgressComponent_div_3_div_2_ng_template_2_Template(rf, ctx) {}\nfunction NzProgressComponent_div_3_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18);\n    i0.ɵɵtemplate(1, NzProgressComponent_div_3_div_2_div_1_Template, 1, 1, \"div\", 19);\n    i0.ɵɵtemplate(2, NzProgressComponent_div_3_div_2_ng_template_2_Template, 0, 0, \"ng-template\", 12);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    const _r0 = i0.ɵɵreference(1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r11.steps);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r0);\n  }\n}\nfunction NzProgressComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtemplate(1, NzProgressComponent_div_3_ng_container_1_Template, 3, 2, \"ng-container\", 2);\n    i0.ɵɵtemplate(2, NzProgressComponent_div_3_div_2_Template, 3, 2, \"div\", 10);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r2.isSteps);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isSteps);\n  }\n}\nfunction NzProgressComponent_div_4__svg_defs_2__svg_stop_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"stop\");\n  }\n  if (rf & 2) {\n    const i_r23 = ctx.$implicit;\n    i0.ɵɵattribute(\"offset\", i_r23.offset)(\"stop-color\", i_r23.color);\n  }\n}\nfunction NzProgressComponent_div_4__svg_defs_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"defs\")(1, \"linearGradient\", 24);\n    i0.ɵɵtemplate(2, NzProgressComponent_div_4__svg_defs_2__svg_stop_2_Template, 1, 2, \"stop\", 25);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", \"gradient-\" + ctx_r19.gradientId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r19.circleGradient);\n  }\n}\nfunction NzProgressComponent_div_4__svg_path_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"path\", 26);\n  }\n  if (rf & 2) {\n    const p_r24 = ctx.$implicit;\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngStyle\", p_r24.strokePathStyle);\n    i0.ɵɵattribute(\"d\", ctx_r20.pathString)(\"stroke-linecap\", ctx_r20.nzStrokeLinecap)(\"stroke\", p_r24.stroke)(\"stroke-width\", ctx_r20.nzPercent ? ctx_r20.strokeWidth : 0);\n  }\n}\nfunction NzProgressComponent_div_4_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n  }\n}\nfunction NzProgressComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(1, \"svg\", 21);\n    i0.ɵɵtemplate(2, NzProgressComponent_div_4__svg_defs_2_Template, 3, 2, \"defs\", 2);\n    i0.ɵɵelement(3, \"path\", 22);\n    i0.ɵɵtemplate(4, NzProgressComponent_div_4__svg_path_4_Template, 1, 5, \"path\", 23);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, NzProgressComponent_div_4_ng_template_5_Template, 0, 0, \"ng-template\", 12);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    const _r0 = i0.ɵɵreference(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r3.nzWidth, \"px\")(\"height\", ctx_r3.nzWidth, \"px\")(\"font-size\", ctx_r3.nzWidth * 0.15 + 6, \"px\");\n    i0.ɵɵclassProp(\"ant-progress-circle-gradient\", ctx_r3.isGradient);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.isGradient);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r3.trailPathStyle);\n    i0.ɵɵattribute(\"stroke-width\", ctx_r3.strokeWidth)(\"d\", ctx_r3.pathString);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.progressCirclePath)(\"ngForTrackBy\", ctx_r3.trackByFn);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r0);\n  }\n}\nfunction stripPercentToNumber(percent) {\n  return +percent.replace('%', '');\n}\nconst sortGradient = gradients => {\n  let tempArr = [];\n  Object.keys(gradients).forEach(key => {\n    const value = gradients[key];\n    const formatKey = stripPercentToNumber(key);\n    if (!isNaN(formatKey)) {\n      tempArr.push({\n        key: formatKey,\n        value\n      });\n    }\n  });\n  tempArr = tempArr.sort((a, b) => a.key - b.key);\n  return tempArr;\n};\nconst handleCircleGradient = strokeColor => sortGradient(strokeColor).map(({\n  key,\n  value\n}) => ({\n  offset: `${key}%`,\n  color: value\n}));\nconst handleLinearGradient = strokeColor => {\n  const {\n    from = '#1890ff',\n    to = '#1890ff',\n    direction = 'to right',\n    ...rest\n  } = strokeColor;\n  if (Object.keys(rest).length !== 0) {\n    const sortedGradients = sortGradient(rest).map(({\n      key,\n      value\n    }) => `${value} ${key}%`).join(', ');\n    return `linear-gradient(${direction}, ${sortedGradients})`;\n  }\n  return `linear-gradient(${direction}, ${from}, ${to})`;\n};\nlet gradientIdSeed = 0;\nconst NZ_CONFIG_MODULE_NAME = 'progress';\nconst statusIconNameMap = new Map([['success', 'check'], ['exception', 'close']]);\nconst statusColorMap = new Map([['normal', '#108ee9'], ['exception', '#ff5500'], ['success', '#87d068']]);\nconst defaultFormatter = p => `${p}%`;\nlet NzProgressComponent = /*#__PURE__*/(() => {\n  class NzProgressComponent {\n    get formatter() {\n      return this.nzFormat || defaultFormatter;\n    }\n    get status() {\n      return this.nzStatus || this.inferredStatus;\n    }\n    get strokeWidth() {\n      return this.nzStrokeWidth || (this.nzType === 'line' && this.nzSize !== 'small' ? 8 : 6);\n    }\n    get isCircleStyle() {\n      return this.nzType === 'circle' || this.nzType === 'dashboard';\n    }\n    constructor(cdr, nzConfigService, directionality) {\n      this.cdr = cdr;\n      this.nzConfigService = nzConfigService;\n      this.directionality = directionality;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzShowInfo = true;\n      this.nzWidth = 132;\n      this.nzStrokeColor = undefined;\n      this.nzSize = 'default';\n      this.nzPercent = 0;\n      this.nzStrokeWidth = undefined;\n      this.nzGapDegree = undefined;\n      this.nzType = 'line';\n      this.nzGapPosition = 'top';\n      this.nzStrokeLinecap = 'round';\n      this.nzSteps = 0;\n      this.steps = [];\n      /** Gradient style when `nzType` is `line`. */\n      this.lineGradient = null;\n      /** If user uses gradient color. */\n      this.isGradient = false;\n      /** If the linear progress is a step progress. */\n      this.isSteps = false;\n      /**\n       * Each progress whose `nzType` is circle or dashboard should have unique id to\n       * define `<linearGradient>`.\n       */\n      this.gradientId = gradientIdSeed++;\n      /** Paths to rendered in the template. */\n      this.progressCirclePath = [];\n      this.trailPathStyle = null;\n      this.dir = 'ltr';\n      this.trackByFn = index => `${index}`;\n      this.cachedStatus = 'normal';\n      this.inferredStatus = 'normal';\n      this.destroy$ = new Subject();\n    }\n    ngOnChanges(changes) {\n      const {\n        nzSteps,\n        nzGapPosition,\n        nzStrokeLinecap,\n        nzStrokeColor,\n        nzGapDegree,\n        nzType,\n        nzStatus,\n        nzPercent,\n        nzSuccessPercent,\n        nzStrokeWidth\n      } = changes;\n      if (nzStatus) {\n        this.cachedStatus = this.nzStatus || this.cachedStatus;\n      }\n      if (nzPercent || nzSuccessPercent) {\n        const fillAll = parseInt(this.nzPercent.toString(), 10) >= 100;\n        if (fillAll) {\n          if (isNotNil(this.nzSuccessPercent) && this.nzSuccessPercent >= 100 || this.nzSuccessPercent === undefined) {\n            this.inferredStatus = 'success';\n          }\n        } else {\n          this.inferredStatus = this.cachedStatus;\n        }\n      }\n      if (nzStatus || nzPercent || nzSuccessPercent || nzStrokeColor) {\n        this.updateIcon();\n      }\n      if (nzStrokeColor) {\n        this.setStrokeColor();\n      }\n      if (nzGapPosition || nzStrokeLinecap || nzGapDegree || nzType || nzPercent || nzStrokeColor || nzStrokeColor) {\n        this.getCirclePaths();\n      }\n      if (nzPercent || nzSteps || nzStrokeWidth) {\n        this.isSteps = this.nzSteps > 0;\n        if (this.isSteps) {\n          this.getSteps();\n        }\n      }\n    }\n    ngOnInit() {\n      this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME).pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.updateIcon();\n        this.setStrokeColor();\n        this.getCirclePaths();\n      });\n      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.cdr.detectChanges();\n      });\n      this.dir = this.directionality.value;\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    updateIcon() {\n      const ret = statusIconNameMap.get(this.status);\n      this.icon = ret ? ret + (this.isCircleStyle ? '-o' : '-circle-fill') : '';\n    }\n    /**\n     * Calculate step render configs.\n     */\n    getSteps() {\n      const current = Math.floor(this.nzSteps * (this.nzPercent / 100));\n      const stepWidth = this.nzSize === 'small' ? 2 : 14;\n      const steps = [];\n      for (let i = 0; i < this.nzSteps; i++) {\n        let color;\n        if (i <= current - 1) {\n          color = this.nzStrokeColor;\n        }\n        const stepStyle = {\n          backgroundColor: `${color}`,\n          width: `${stepWidth}px`,\n          height: `${this.strokeWidth}px`\n        };\n        steps.push(stepStyle);\n      }\n      this.steps = steps;\n    }\n    /**\n     * Calculate paths when the type is circle or dashboard.\n     */\n    getCirclePaths() {\n      if (!this.isCircleStyle) {\n        return;\n      }\n      const values = isNotNil(this.nzSuccessPercent) ? [this.nzSuccessPercent, this.nzPercent] : [this.nzPercent];\n      // Calculate shared styles.\n      const radius = 50 - this.strokeWidth / 2;\n      const gapPosition = this.nzGapPosition || (this.nzType === 'circle' ? 'top' : 'bottom');\n      const len = Math.PI * 2 * radius;\n      const gapDegree = this.nzGapDegree || (this.nzType === 'circle' ? 0 : 75);\n      let beginPositionX = 0;\n      let beginPositionY = -radius;\n      let endPositionX = 0;\n      let endPositionY = radius * -2;\n      switch (gapPosition) {\n        case 'left':\n          beginPositionX = -radius;\n          beginPositionY = 0;\n          endPositionX = radius * 2;\n          endPositionY = 0;\n          break;\n        case 'right':\n          beginPositionX = radius;\n          beginPositionY = 0;\n          endPositionX = radius * -2;\n          endPositionY = 0;\n          break;\n        case 'bottom':\n          beginPositionY = radius;\n          endPositionY = radius * 2;\n          break;\n        default:\n      }\n      this.pathString = `M 50,50 m ${beginPositionX},${beginPositionY}\n       a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}\n       a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;\n      this.trailPathStyle = {\n        strokeDasharray: `${len - gapDegree}px ${len}px`,\n        strokeDashoffset: `-${gapDegree / 2}px`,\n        transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s'\n      };\n      // Calculate styles for each path.\n      this.progressCirclePath = values.map((value, index) => {\n        const isSuccessPercent = values.length === 2 && index === 0;\n        return {\n          stroke: this.isGradient && !isSuccessPercent ? `url(#gradient-${this.gradientId})` : null,\n          strokePathStyle: {\n            stroke: !this.isGradient ? isSuccessPercent ? statusColorMap.get('success') : this.nzStrokeColor : null,\n            transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s',\n            strokeDasharray: `${(value || 0) / 100 * (len - gapDegree)}px ${len}px`,\n            strokeDashoffset: `-${gapDegree / 2}px`\n          }\n        };\n      }).reverse();\n    }\n    setStrokeColor() {\n      const color = this.nzStrokeColor;\n      const isGradient = this.isGradient = !!color && typeof color !== 'string';\n      if (isGradient && !this.isCircleStyle) {\n        this.lineGradient = handleLinearGradient(color);\n      } else if (isGradient && this.isCircleStyle) {\n        this.circleGradient = handleCircleGradient(this.nzStrokeColor);\n      } else {\n        this.lineGradient = null;\n        this.circleGradient = [];\n      }\n    }\n    static #_ = this.ɵfac = function NzProgressComponent_Factory(t) {\n      return new (t || NzProgressComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.NzConfigService), i0.ɵɵdirectiveInject(i2.Directionality, 8));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NzProgressComponent,\n      selectors: [[\"nz-progress\"]],\n      inputs: {\n        nzShowInfo: \"nzShowInfo\",\n        nzWidth: \"nzWidth\",\n        nzStrokeColor: \"nzStrokeColor\",\n        nzSize: \"nzSize\",\n        nzFormat: \"nzFormat\",\n        nzSuccessPercent: \"nzSuccessPercent\",\n        nzPercent: \"nzPercent\",\n        nzStrokeWidth: \"nzStrokeWidth\",\n        nzGapDegree: \"nzGapDegree\",\n        nzStatus: \"nzStatus\",\n        nzType: \"nzType\",\n        nzGapPosition: \"nzGapPosition\",\n        nzStrokeLinecap: \"nzStrokeLinecap\",\n        nzSteps: \"nzSteps\"\n      },\n      exportAs: [\"nzProgress\"],\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 5,\n      vars: 17,\n      consts: [[\"progressInfoTemplate\", \"\"], [3, \"ngClass\"], [4, \"ngIf\"], [\"class\", \"ant-progress-inner\", 3, \"width\", \"height\", \"fontSize\", \"ant-progress-circle-gradient\", 4, \"ngIf\"], [\"class\", \"ant-progress-text\", 4, \"ngIf\"], [1, \"ant-progress-text\"], [4, \"ngIf\", \"ngIfElse\"], [\"formatTemplate\", \"\"], [\"nz-icon\", \"\", 3, \"nzType\"], [4, \"nzStringTemplateOutlet\", \"nzStringTemplateOutletContext\"], [\"class\", \"ant-progress-steps-outer\", 4, \"ngIf\"], [\"class\", \"ant-progress-outer\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\"], [1, \"ant-progress-outer\"], [1, \"ant-progress-inner\"], [1, \"ant-progress-bg\"], [\"class\", \"ant-progress-success-bg\", 3, \"width\", \"border-radius\", \"height\", 4, \"ngIf\"], [1, \"ant-progress-success-bg\"], [1, \"ant-progress-steps-outer\"], [\"class\", \"ant-progress-steps-item\", 3, \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [1, \"ant-progress-steps-item\", 3, \"ngStyle\"], [\"viewBox\", \"0 0 100 100\", 1, \"ant-progress-circle\"], [\"stroke\", \"#f3f3f3\", \"fill-opacity\", \"0\", 1, \"ant-progress-circle-trail\", 3, \"ngStyle\"], [\"class\", \"ant-progress-circle-path\", \"fill-opacity\", \"0\", 3, \"ngStyle\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"x1\", \"100%\", \"y1\", \"0%\", \"x2\", \"0%\", \"y2\", \"0%\", 3, \"id\"], [4, \"ngFor\", \"ngForOf\"], [\"fill-opacity\", \"0\", 1, \"ant-progress-circle-path\", 3, \"ngStyle\"]],\n      template: function NzProgressComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, NzProgressComponent_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n          i0.ɵɵelementStart(2, \"div\", 1);\n          i0.ɵɵtemplate(3, NzProgressComponent_div_3_Template, 3, 2, \"div\", 2);\n          i0.ɵɵtemplate(4, NzProgressComponent_div_4_Template, 6, 15, \"div\", 3);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(2);\n          i0.ɵɵclassProp(\"ant-progress-line\", ctx.nzType === \"line\")(\"ant-progress-small\", ctx.nzSize === \"small\")(\"ant-progress-default\", ctx.nzSize === \"default\")(\"ant-progress-show-info\", ctx.nzShowInfo)(\"ant-progress-circle\", ctx.isCircleStyle)(\"ant-progress-steps\", ctx.isSteps)(\"ant-progress-rtl\", ctx.dir === \"rtl\");\n          i0.ɵɵproperty(\"ngClass\", \"ant-progress ant-progress-status-\" + ctx.status);\n          i0.ɵɵadvance(1);\n          i0.ɵɵproperty(\"ngIf\", ctx.nzType === \"line\");\n          i0.ɵɵadvance(1);\n          i0.ɵɵproperty(\"ngIf\", ctx.isCircleStyle);\n        }\n      },\n      dependencies: [i3.NgClass, i3.NgForOf, i3.NgIf, i3.NgTemplateOutlet, i3.NgStyle, i4.NzIconDirective, i5.NzStringTemplateOutletDirective],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  __decorate([WithConfig()], NzProgressComponent.prototype, \"nzShowInfo\", void 0);\n  __decorate([WithConfig()], NzProgressComponent.prototype, \"nzStrokeColor\", void 0);\n  __decorate([WithConfig()], NzProgressComponent.prototype, \"nzSize\", void 0);\n  __decorate([InputNumber()], NzProgressComponent.prototype, \"nzSuccessPercent\", void 0);\n  __decorate([InputNumber()], NzProgressComponent.prototype, \"nzPercent\", void 0);\n  __decorate([WithConfig(), InputNumber()], NzProgressComponent.prototype, \"nzStrokeWidth\", void 0);\n  __decorate([WithConfig(), InputNumber()], NzProgressComponent.prototype, \"nzGapDegree\", void 0);\n  __decorate([WithConfig()], NzProgressComponent.prototype, \"nzGapPosition\", void 0);\n  __decorate([WithConfig()], NzProgressComponent.prototype, \"nzStrokeLinecap\", void 0);\n  __decorate([InputNumber()], NzProgressComponent.prototype, \"nzSteps\", void 0);\n  return NzProgressComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzProgressModule = /*#__PURE__*/(() => {\n  class NzProgressModule {\n    static #_ = this.ɵfac = function NzProgressModule_Factory(t) {\n      return new (t || NzProgressModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NzProgressModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [BidiModule, CommonModule, NzIconModule, NzOutletModule]\n    });\n  }\n  return NzProgressModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzProgressComponent, NzProgressModule };\n//# sourceMappingURL=ng-zorro-antd-progress.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}