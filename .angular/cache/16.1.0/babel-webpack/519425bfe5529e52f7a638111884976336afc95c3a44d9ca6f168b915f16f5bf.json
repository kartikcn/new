{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Optional, Input, Host, NgModule } from '@angular/core';\nimport { ReplaySubject, Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i3 from 'ng-zorro-antd/core/services';\nimport { gridResponsiveMap } from 'ng-zorro-antd/core/services';\nimport * as i1 from '@angular/cdk/layout';\nimport { LayoutModule } from '@angular/cdk/layout';\nimport * as i2 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport * as i4 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport { isNotNil } from 'ng-zorro-antd/core/util';\nimport { CommonModule } from '@angular/common';\nlet NzRowDirective = /*#__PURE__*/(() => {\n  class NzRowDirective {\n    getGutter() {\n      const results = [null, null];\n      const gutter = this.nzGutter || 0;\n      const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, null];\n      normalizedGutter.forEach((g, index) => {\n        if (typeof g === 'object' && g !== null) {\n          results[index] = null;\n          Object.keys(gridResponsiveMap).map(screen => {\n            const bp = screen;\n            if (this.mediaMatcher.matchMedia(gridResponsiveMap[bp]).matches && g[bp]) {\n              results[index] = g[bp];\n            }\n          });\n        } else {\n          results[index] = Number(g) || null;\n        }\n      });\n      return results;\n    }\n    setGutterStyle() {\n      const [horizontalGutter, verticalGutter] = this.getGutter();\n      this.actualGutter$.next([horizontalGutter, verticalGutter]);\n      const renderGutter = (name, gutter) => {\n        const nativeElement = this.elementRef.nativeElement;\n        if (gutter !== null) {\n          this.renderer.setStyle(nativeElement, name, `-${gutter / 2}px`);\n        }\n      };\n      renderGutter('margin-left', horizontalGutter);\n      renderGutter('margin-right', horizontalGutter);\n      renderGutter('margin-top', verticalGutter);\n      renderGutter('margin-bottom', verticalGutter);\n    }\n    constructor(elementRef, renderer, mediaMatcher, ngZone, platform, breakpointService, directionality) {\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.mediaMatcher = mediaMatcher;\n      this.ngZone = ngZone;\n      this.platform = platform;\n      this.breakpointService = breakpointService;\n      this.directionality = directionality;\n      this.nzAlign = null;\n      this.nzJustify = null;\n      this.nzGutter = null;\n      this.actualGutter$ = new ReplaySubject(1);\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n    }\n    ngOnInit() {\n      this.dir = this.directionality.value;\n      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n      this.setGutterStyle();\n    }\n    ngOnChanges(changes) {\n      if (changes.nzGutter) {\n        this.setGutterStyle();\n      }\n    }\n    ngAfterViewInit() {\n      if (this.platform.isBrowser) {\n        this.breakpointService.subscribe(gridResponsiveMap).pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.setGutterStyle();\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    static #_ = this.ɵfac = function NzRowDirective_Factory(t) {\n      return new (t || NzRowDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.MediaMatcher), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(i3.NzBreakpointService), i0.ɵɵdirectiveInject(i4.Directionality, 8));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NzRowDirective,\n      selectors: [[\"\", \"nz-row\", \"\"], [\"nz-row\"], [\"nz-form-item\"]],\n      hostAttrs: [1, \"ant-row\"],\n      hostVars: 20,\n      hostBindings: function NzRowDirective_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"ant-row-top\", ctx.nzAlign === \"top\")(\"ant-row-middle\", ctx.nzAlign === \"middle\")(\"ant-row-bottom\", ctx.nzAlign === \"bottom\")(\"ant-row-start\", ctx.nzJustify === \"start\")(\"ant-row-end\", ctx.nzJustify === \"end\")(\"ant-row-center\", ctx.nzJustify === \"center\")(\"ant-row-space-around\", ctx.nzJustify === \"space-around\")(\"ant-row-space-between\", ctx.nzJustify === \"space-between\")(\"ant-row-space-evenly\", ctx.nzJustify === \"space-evenly\")(\"ant-row-rtl\", ctx.dir === \"rtl\");\n        }\n      },\n      inputs: {\n        nzAlign: \"nzAlign\",\n        nzJustify: \"nzJustify\",\n        nzGutter: \"nzGutter\"\n      },\n      exportAs: [\"nzRow\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NzRowDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NzColDirective = /*#__PURE__*/(() => {\n  class NzColDirective {\n    setHostClassMap() {\n      const hostClassMap = {\n        ['ant-col']: true,\n        [`ant-col-${this.nzSpan}`]: isNotNil(this.nzSpan),\n        [`ant-col-order-${this.nzOrder}`]: isNotNil(this.nzOrder),\n        [`ant-col-offset-${this.nzOffset}`]: isNotNil(this.nzOffset),\n        [`ant-col-pull-${this.nzPull}`]: isNotNil(this.nzPull),\n        [`ant-col-push-${this.nzPush}`]: isNotNil(this.nzPush),\n        ['ant-col-rtl']: this.dir === 'rtl',\n        ...this.generateClass()\n      };\n      for (const i in this.classMap) {\n        if (this.classMap.hasOwnProperty(i)) {\n          this.renderer.removeClass(this.elementRef.nativeElement, i);\n        }\n      }\n      this.classMap = {\n        ...hostClassMap\n      };\n      for (const i in this.classMap) {\n        if (this.classMap.hasOwnProperty(i) && this.classMap[i]) {\n          this.renderer.addClass(this.elementRef.nativeElement, i);\n        }\n      }\n    }\n    setHostFlexStyle() {\n      this.hostFlexStyle = this.parseFlex(this.nzFlex);\n    }\n    parseFlex(flex) {\n      if (typeof flex === 'number') {\n        return `${flex} ${flex} auto`;\n      } else if (typeof flex === 'string') {\n        if (/^\\d+(\\.\\d+)?(px|em|rem|%)$/.test(flex)) {\n          return `0 0 ${flex}`;\n        }\n      }\n      return flex;\n    }\n    generateClass() {\n      const listOfSizeInputName = ['nzXs', 'nzSm', 'nzMd', 'nzLg', 'nzXl', 'nzXXl'];\n      const listClassMap = {};\n      listOfSizeInputName.forEach(name => {\n        const sizeName = name.replace('nz', '').toLowerCase();\n        if (isNotNil(this[name])) {\n          if (typeof this[name] === 'number' || typeof this[name] === 'string') {\n            listClassMap[`ant-col-${sizeName}-${this[name]}`] = true;\n          } else {\n            const embedded = this[name];\n            const prefixArray = ['span', 'pull', 'push', 'offset', 'order'];\n            prefixArray.forEach(prefix => {\n              const prefixClass = prefix === 'span' ? '-' : `-${prefix}-`;\n              listClassMap[`ant-col-${sizeName}${prefixClass}${embedded[prefix]}`] = embedded && isNotNil(embedded[prefix]);\n            });\n          }\n        }\n      });\n      return listClassMap;\n    }\n    constructor(elementRef, nzRowDirective, renderer, directionality) {\n      this.elementRef = elementRef;\n      this.nzRowDirective = nzRowDirective;\n      this.renderer = renderer;\n      this.directionality = directionality;\n      this.classMap = {};\n      this.destroy$ = new Subject();\n      this.hostFlexStyle = null;\n      this.dir = 'ltr';\n      this.nzFlex = null;\n      this.nzSpan = null;\n      this.nzOrder = null;\n      this.nzOffset = null;\n      this.nzPush = null;\n      this.nzPull = null;\n      this.nzXs = null;\n      this.nzSm = null;\n      this.nzMd = null;\n      this.nzLg = null;\n      this.nzXl = null;\n      this.nzXXl = null;\n    }\n    ngOnInit() {\n      this.dir = this.directionality.value;\n      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.setHostClassMap();\n      });\n      this.setHostClassMap();\n      this.setHostFlexStyle();\n    }\n    ngOnChanges(changes) {\n      this.setHostClassMap();\n      const {\n        nzFlex\n      } = changes;\n      if (nzFlex) {\n        this.setHostFlexStyle();\n      }\n    }\n    ngAfterViewInit() {\n      if (this.nzRowDirective) {\n        this.nzRowDirective.actualGutter$.pipe(takeUntil(this.destroy$)).subscribe(([horizontalGutter, verticalGutter]) => {\n          const renderGutter = (name, gutter) => {\n            const nativeElement = this.elementRef.nativeElement;\n            if (gutter !== null) {\n              this.renderer.setStyle(nativeElement, name, `${gutter / 2}px`);\n            }\n          };\n          renderGutter('padding-left', horizontalGutter);\n          renderGutter('padding-right', horizontalGutter);\n          renderGutter('padding-top', verticalGutter);\n          renderGutter('padding-bottom', verticalGutter);\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    static #_ = this.ɵfac = function NzColDirective_Factory(t) {\n      return new (t || NzColDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NzRowDirective, 9), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i4.Directionality, 8));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NzColDirective,\n      selectors: [[\"\", \"nz-col\", \"\"], [\"nz-col\"], [\"nz-form-control\"], [\"nz-form-label\"]],\n      hostVars: 2,\n      hostBindings: function NzColDirective_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"flex\", ctx.hostFlexStyle);\n        }\n      },\n      inputs: {\n        nzFlex: \"nzFlex\",\n        nzSpan: \"nzSpan\",\n        nzOrder: \"nzOrder\",\n        nzOffset: \"nzOffset\",\n        nzPush: \"nzPush\",\n        nzPull: \"nzPull\",\n        nzXs: \"nzXs\",\n        nzSm: \"nzSm\",\n        nzMd: \"nzMd\",\n        nzLg: \"nzLg\",\n        nzXl: \"nzXl\",\n        nzXXl: \"nzXXl\"\n      },\n      exportAs: [\"nzCol\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NzColDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzGridModule = /*#__PURE__*/(() => {\n  class NzGridModule {\n    static #_ = this.ɵfac = function NzGridModule_Factory(t) {\n      return new (t || NzGridModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NzGridModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [BidiModule, CommonModule, LayoutModule, PlatformModule]\n    });\n  }\n  return NzGridModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzColDirective, NzGridModule, NzRowDirective };\n//# sourceMappingURL=ng-zorro-antd-grid.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}